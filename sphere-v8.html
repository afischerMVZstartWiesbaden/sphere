<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ProjektSphere</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400&family=DM+Mono:wght@300;400&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#07080f; overflow:hidden; height:100vh; width:100vw; cursor:grab; }
  body.grabbing { cursor:grabbing; }
  canvas { display:block; position:fixed; top:0; left:0; }

  #header {
    position:fixed; top:28px; left:40px;
    background:rgba(7,8,15,0.75); backdrop-filter:blur(20px);
    border:1px solid rgba(180,170,140,0.1);
    padding:14px 24px 12px; border-radius:3px; z-index:10;
  }
  .eyebrow { font-family:'DM Mono',monospace; font-size:9px; letter-spacing:0.32em;
    text-transform:uppercase; color:rgba(136,120,88,0.65); margin-bottom:5px; }
  .title { font-family:'Inter',sans-serif; font-size:22px; font-weight:200;
    letter-spacing:0.14em; color:rgba(220,210,180,0.88); }

  #controls {
    position:fixed; top:28px; right:40px; z-index:10;
    display:flex; gap:4px;
    background:rgba(7,8,15,0.75); backdrop-filter:blur(20px);
    border:1px solid rgba(180,170,140,0.1); padding:7px 12px; border-radius:3px;
  }
  .btn { font-family:'DM Mono',monospace; font-size:10px; letter-spacing:0.14em;
    text-transform:uppercase; color:rgba(136,120,88,0.55); background:transparent;
    border:none; cursor:pointer; transition:color 0.2s; padding:3px 10px; }
  .btn:hover { color:rgba(220,210,180,0.9); }
  .btn.hidden { display:none; }
  .btn + .btn { border-left:1px solid rgba(180,170,140,0.08); }

  #detail {
    position:fixed; right:40px; bottom:40px; width:275px; z-index:10;
    background:rgba(7,8,15,0.82); backdrop-filter:blur(20px);
    border:1px solid rgba(74,138,176,0.22);
    padding:20px 22px 18px; border-radius:3px;
    opacity:0; transform:translateY(8px);
    transition:all 0.38s cubic-bezier(0.16,1,0.3,1); pointer-events:none;
  }
  #detail.show { opacity:1; transform:translateY(0); }
  .d-tag { font-family:'DM Mono',monospace; font-size:9px; letter-spacing:0.24em;
    text-transform:uppercase; color:rgba(74,138,176,0.65); margin-bottom:9px; }
  .d-name { font-family:'Inter',sans-serif; font-size:22px; font-weight:200;
    letter-spacing:0.06em; color:rgba(220,210,180,0.92); margin-bottom:4px; }
  .d-desc { font-family:'DM Mono',monospace; font-size:10px;
    color:rgba(136,120,88,0.55); margin-bottom:14px; }
  .d-list { list-style:none; }
  .d-list li { font-family:'Inter',sans-serif; font-size:13px; font-weight:300;
    color:rgba(200,188,155,0.5); padding:5px 0;
    border-bottom:1px solid rgba(200,188,155,0.07);
    display:flex; align-items:center; gap:9px; }
  .d-list li:last-child { border:none; }
  .d-pip { width:4px; height:4px; border-radius:50%; flex-shrink:0; }

  #hint {
    position:fixed; bottom:26px; left:50%; transform:translateX(-50%); z-index:10;
    font-family:'DM Mono',monospace; font-size:9px; letter-spacing:0.22em;
    text-transform:uppercase; color:rgba(136,120,88,0.28); white-space:nowrap;
    background:rgba(7,8,15,0.5); padding:6px 14px; border-radius:2px;
    border:1px solid rgba(180,170,140,0.05); pointer-events:none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="header">
  <div class="eyebrow">MVZ Start Wiesbaden</div>
  <div class="title">Projekt Sphere</div>
</div>
<div id="controls">
  <button class="btn hidden" id="btn-back" onclick="navigateBack()">← Zurück</button>
  <button class="btn" onclick="resetView()">Zentrieren</button>
    <button class="btn" onclick="toggleBg()" id="btn-bg">✦ Weltraum</button>
</div>
<div id="detail">
  <div class="d-tag" id="d-tag"></div>
  <div class="d-name" id="d-name"></div>
  <div class="d-desc" id="d-desc"></div>
  <ul class="d-list" id="d-list"></ul>
</div>
<div id="hint">Ziehen = Orbit · Scroll / Pinch = Zoom · Rechte Maus = Eintauchen · Klick = Auswählen</div>

<script>
// ─── DATA ─────────────────────────────────────────────────────────────────
const DATA = [
  { id:'stundendoku', label:'Stundendoku',  desc:'Zeiterfassung & Abgleich',  color:'#7B9E9E', icon:'clock',     connections:['rechnungen','protokolle'], children:[
    { id:'sd1', label:'Import Makro',  path:'Stundendoku/skripte/', color:'#7B9E9E', icon:'file', connections:['sd2','sd3','r1'] },
    { id:'sd2', label:'Epikur Export', path:'Stundendoku/tools/',   color:'#7B9E9E', icon:'file', connections:['sd1','sd3'] },
    { id:'sd3', label:'IVP Abgleich',  path:'Stundendoku/skripte/', color:'#7B9E9E', icon:'file', connections:['sd1','r1'] },
    { id:'sd4', label:'Status Memo',   path:'Stundendoku/expose/',  color:'#7B9E9E', icon:'file', connections:['p4'] },
  ]},
  { id:'rechnungen',  label:'Rechnungen',   desc:'Billing Workflows',         color:'#B87878', icon:'invoice',   connections:['stundendoku','diagnostik'], children:[
    { id:'r1', label:'IVP Workflow',   path:'Rechnungen/skripte/',  color:'#B87878', icon:'file', connections:['sd3','r3'] },
    { id:'r2', label:'Export Archiv',  path:'Rechnungen/archiv/',   color:'#B87878', icon:'file', connections:['r3'] },
    { id:'r3', label:'BTT Shortcuts',  path:'BetterTouchTool',      color:'#B87878', icon:'file', connections:['r1','r2'] },
  ]},
  { id:'diagnostik',  label:'Diagnostik',   desc:'Psycholog. Diagnostik',     color:'#8A7BA8', icon:'clipboard', connections:['rechnungen','netzwerk'], children:[
    { id:'d1', label:'PsychoEQ',       path:'lokal/psychoeq/',      color:'#8A7BA8', icon:'file', connections:['n2','d3'] },
    { id:'d2', label:'QR Tutorials',   path:'Diagnostik/expose/',   color:'#8A7BA8', icon:'file', connections:['d3'] },
    { id:'d3', label:'Makro Export',   path:'Diagnostik/skripte/',  color:'#8A7BA8', icon:'file', connections:['d1','d2'] },
  ]},
  { id:'netzwerk',    label:'IT / Netzwerk',desc:'Infrastruktur Praxis',      color:'#A89870', icon:'network',   connections:['diagnostik','protokolle'], children:[
    { id:'n1', label:'WLAN Doku',      path:'IT/netzwerk/',         color:'#A89870', icon:'file', connections:['n3'] },
    { id:'n2', label:'WireGuard VPN',  path:'lokal/vpn/',           color:'#A89870', icon:'file', connections:['d1','n1'] },
    { id:'n3', label:'Patch Panel',    path:'IT/netzwerk/',         color:'#A89870', icon:'file', connections:['n1'] },
  ]},
  { id:'protokolle',  label:'Protokolle',   desc:'Meeting Automation',        color:'#6E9E82', icon:'terminal',  connections:['stundendoku','netzwerk'], children:[
    { id:'p1', label:'Whisper',        path:'lokal/ki-tools/',      color:'#6E9E82', icon:'file', connections:['p2','p3'] },
    { id:'p2', label:'Ollama Qwen3',   path:'lokal/ki-tools/',      color:'#6E9E82', icon:'file', connections:['p1','p3'] },
    { id:'p3', label:'DSGVO Check',    path:'lokal/ki-tools/',      color:'#6E9E82', icon:'file', connections:['p1','p2'] },
    { id:'p4', label:'Exposé Template',path:'Protokolle/expose/',   color:'#6E9E82', icon:'file', connections:['sd4'] },
  ]},
];
const NODE_MAP = {};
DATA.forEach(d=>{NODE_MAP[d.id]=d;(d.children||[]).forEach(c=>NODE_MAP[c.id]=c);});

// ─── CANVAS ───────────────────────────────────────────────────────────────
let W=window.innerWidth, H=window.innerHeight;
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
canvas.width=W; canvas.height=H;

// ─── ORBIT CAMERA ─────────────────────────────────────────────────────────
// Always orbits around (0,0,0). No free-flying confusion.
let orbitYaw   = 0.3;     // horizontal angle
let orbitPitch = 0.2;     // vertical angle (clamped)
let orbitDist  = 2.8;     // distance from center
let targetYaw  = 0.3;
let targetPitch= 0.2;
let targetDist = 2.8;

// Right-mouse dive: temporarily reduces distance smoothly
let diveActive = false;
let diveDelta  = 0;  // accumulated dive

// Drag state
let isDragging=false, dragBtn=0, dragX=0, dragY=0;
let glowT=0;

// ─── NODES ────────────────────────────────────────────────────────────────
let nodes=[], currentData=DATA, navStack=[];
let selected=null, hovered=null;

let bgMode = 'space'; // 'space' | 'circuit' | 'white'
function toggleBg(){
  bgMode = bgMode==='space'?'circuit':bgMode==='circuit'?'white':'space';
  document.getElementById('btn-bg').textContent = bgMode==='space'?'✦ Weltraum':bgMode==='circuit'?'⬡ Circuit':'◻ Beige';
}

// Stars: stored as angular direction (yaw/pitch offsets from forward) + size
// Rendered as a skybox - they rotate with camera view but are always "behind" scene
const stars=Array.from({length:700},()=>({
  yaw:   Math.random()*Math.PI*2,       // direction around sphere
  pitch: (Math.random()-0.5)*Math.PI,   // elevation
  s:     Math.random()*2.4+0.3,
  tw:    Math.random()*Math.PI*2,
  spd:   Math.random()*1.1+0.3,
  warm:  Math.random()>0.65,
}));

// Project a star direction to screen (skybox projection)
function projectStar(yaw, pitch){
  // Direction vector for this star
  const dx=Math.cos(pitch)*Math.sin(yaw);
  const dy=Math.sin(pitch);
  const dz=Math.cos(pitch)*Math.cos(yaw);
  // Apply camera rotation (inverse of orbit)
  const cy2=Math.cos(-orbitYaw), sy2=Math.sin(-orbitYaw);
  const x1=dx*cy2+dz*sy2, z1=-dx*sy2+dz*cy2;
  const cp2=Math.cos(-orbitPitch), sp2=Math.sin(-orbitPitch);
  const y2=dy*cp2-z1*sp2, vz2=dy*sp2+z1*cp2;
  if(vz2<0.01) return null; // behind camera
  const scale=600/vz2;
  return {sx:W/2+x1*scale, sy:H/2-y2*scale};
}

// Circuit dust cloud – true 3D, projected with camera
const dustCloud = (()=>{
  const grains=[];
  const rng=(s)=>{let x=s;return()=>{x=Math.sin(x*127.1+311.7)*43758.5453;return x-Math.floor(x);}};
  const r=rng(77);
  // 3000 grains scattered in a sphere of radius ~4 around origin
  // Clustered: generate cluster centers first, then grains around them
  const numClusters=120;
  for(let ci=0;ci<numClusters;ci++){
    // Cluster center in 3D space
    const th=r()*Math.PI*2, ph=Math.acos(2*r()-1);
    const rad=0.3+r()*3.8; // spread from close to far
    const cx3=rad*Math.sin(ph)*Math.cos(th);
    const cy3=rad*Math.sin(ph)*Math.sin(th);
    const cz3=rad*Math.cos(ph);
    const type=r()>0.45?'dense':r()>0.2?'medium':'wisp';
    const count=type==='dense'?35+Math.floor(r()*50):type==='medium'?14+Math.floor(r()*20):5+Math.floor(r()*10);
    const spread=type==='dense'?0.06+r()*0.14:type==='medium'?0.12+r()*0.25:0.2+r()*0.5;
    for(let gi=0;gi<count;gi++){
      const ga=r()*Math.PI*2, gp=Math.acos(2*r()-1);
      const gd=Math.pow(r(),1.6)*spread; // power falloff
      grains.push({
        x: cx3+gd*Math.sin(gp)*Math.cos(ga),
        y: cy3+gd*Math.sin(gp)*Math.sin(ga),
        z: cz3+gd*Math.cos(gp),
        size: r()*0.9+0.15,
        bright: type==='dense'?Math.round(50+r()*80):Math.round(75+r()*130),
        alpha: type==='dense'?0.15+r()*0.55:0.07+r()*0.32,
        phase: r()*Math.PI*2,
        spd: 0.15+r()*0.5,
      });
    }
  }
  return grains;
})();

// Circuit dots – pre-generated grid with randomization
const circuitDots = (()=>{
  const dots=[]; const rng=(s)=>{let x=s;return()=>{x=Math.sin(x*127.1+311.7)*43758.5;return x-Math.floor(x);}};
  const r=rng(42);
  const gx=24, gy=22;
  for(let col=0; col<80; col++){
    for(let row=0; row<50; row++){
      const v=r();
      if(v>0.52) continue; // sparse
      const ox=(r()-0.5)*8, oy=(r()-0.5)*8;
      const bright=r();
      dots.push({
        gx: col*gx+ox, gy: row*gy+oy,
        size: bright>0.96?2.8:bright>0.88?1.6:0.8,
        alpha: bright>0.96?0.75:bright>0.88?0.40:0.16,
        pulse: bright>0.96, // bright dots pulse
        phase: r()*Math.PI*2,
      });
    }
  }
  return dots;
})();

function buildNodes(data){
  nodes=[];
  const phi=Math.PI*(3-Math.sqrt(5));
  data.forEach((item,i)=>{
    const y=1-(i/Math.max(data.length-1,1))*2;
    const r=Math.sqrt(Math.max(0,1-y*y));
    const th=phi*i;
    nodes.push({item, x3:Math.cos(th)*r, y3:y, z3:Math.sin(th)*r,
      isParent:!!(item.children&&item.children.length),
      fp:Math.random()*Math.PI*2, fs:0.3+Math.random()*0.3, fa:0.014+Math.random()*0.016});
  });
}
buildNodes(DATA);

// ─── PROJECTION (orbit-based) ─────────────────────────────────────────────
// Camera position derived purely from orbit angles + distance
function getCamera(){
  const cy=Math.cos(orbitYaw), sy=Math.sin(orbitYaw);
  const cp=Math.cos(orbitPitch), sp=Math.sin(orbitPitch);
  return {
    x: orbitDist*sy*cp,
    y: orbitDist*sp,
    z: orbitDist*cy*cp
  };
}

function project(x3,y3,z3){
  const cam=getCamera();
  // View matrix: look from cam toward (0,0,0)
  // Forward = normalize(-cam)
  const fx=-cam.x, fy=-cam.y, fz=-cam.z;
  const fl=Math.sqrt(fx*fx+fy*fy+fz*fz);
  const fnx=fx/fl, fny=fy/fl, fnz=fz/fl;
  // Right = forward × worldUp
  const ux=0,uy=1,uz=0;
  let rx=fny*uz-fnz*uy, ry=fnz*ux-fnx*uz, rz=fnx*uy-fny*ux;
  const rl=Math.sqrt(rx*rx+ry*ry+rz*rz)||1;
  rx/=rl; ry/=rl; rz/=rl;
  // Up = right × forward
  const upx=ry*fnz-rz*fny, upy=rz*fnx-rx*fnz, upz=rx*fny-ry*fnx;
  // Translate to camera space
  const tx=x3-cam.x, ty=y3-cam.y, tz=z3-cam.z;
  const vx=tx*rx+ty*ry+tz*rz;
  const vy=tx*upx+ty*upy+tz*upz;
  const vz=tx*fnx+ty*fny+tz*fnz; // depth (positive = in front)
  if(vz<0.05) return {sx:-9999,sy:-9999,d:0,vz};
  const fov=700;
  const scale=fov/vz;
  return {sx:W/2+vx*scale, sy:H/2-vy*scale, d:Math.min(2.0, scale/250), vz};
}

// ─── HIT TEST ─────────────────────────────────────────────────────────────
function getNodeAt(mx,my){
  return [...nodes]
    .map(n=>{
      const ox=n.fa*Math.sin(glowT*n.fs+n.fp);
      const oy=n.fa*Math.cos(glowT*n.fs*0.7+n.fp+1);
      return {n, p:project(n.x3+ox,n.y3+oy,n.z3+ox*0.5)};
    })
    .sort((a,b)=>b.p.d-a.p.d)
    .find(({n,p})=>{
      if(p.d<=0)return false;
      const R=(n.isParent?42:28)*p.d;
      const dx=mx-p.sx, dy=my-p.sy;
      return Math.sqrt(dx*dx+dy*dy)<R*1.5;
    })?.n||null;
}

// ─── EVENTS ───────────────────────────────────────────────────────────────
canvas.addEventListener('mousedown',e=>{
  isDragging=true; dragBtn=e.button; dragX=e.clientX; dragY=e.clientY;
  if(e.button===2){diveActive=true; e.preventDefault();}
  else document.body.classList.add('grabbing');
});
canvas.addEventListener('contextmenu',e=>e.preventDefault());

window.addEventListener('mouseup',e=>{
  if(!isDragging)return;
  const moved=Math.abs(e.clientX-dragX)+Math.abs(e.clientY-dragY);
  isDragging=false; diveActive=false;
  document.body.classList.remove('grabbing');
  if(moved<5&&e.button===0) handleClick(e.clientX,e.clientY);
});

window.addEventListener('mousemove',e=>{
  if(!isDragging){
    hovered=getNodeAt(e.clientX,e.clientY);
    canvas.style.cursor=hovered?'pointer':'grab';
    return;
  }
  const dx=e.clientX-dragX, dy=e.clientY-dragY;
  dragX=e.clientX; dragY=e.clientY;

  if(dragBtn===2){
    // Right drag: dive in/out (vertical) + strafe yaw (horizontal), gentle
    diveDelta += dy*0.004;
    targetYaw  += dx*0.004;
  } else {
    // Left drag: orbit
    targetYaw   += dx*0.007;
    targetPitch -= dy*0.005;
    targetPitch  = Math.max(-1.3,Math.min(1.3,targetPitch));
  }
  canvas.style.cursor='grabbing';
});

canvas.addEventListener('wheel',e=>{
  e.preventDefault();
  // Smooth zoom toward/away from center
  targetDist = Math.max(0.6, Math.min(5.0, targetDist + e.deltaY*0.003));
},{passive:false});

// Touch support
let touch0=null, touch1=null, lastPinchDist=0;
let lastTapTime=0, tapX=0, tapY=0;
canvas.addEventListener('touchstart',e=>{
  e.preventDefault();
  if(e.touches.length===1){
    isDragging=true;dragBtn=0;
    dragX=e.touches[0].clientX;dragY=e.touches[0].clientY;
    tapX=dragX;tapY=dragY;
  }
  if(e.touches.length===2){
    isDragging=false;
    lastPinchDist=Math.hypot(
      e.touches[1].clientX-e.touches[0].clientX,
      e.touches[1].clientY-e.touches[0].clientY);
  }
},{passive:false});
canvas.addEventListener('touchmove',e=>{
  e.preventDefault();
  if(e.touches.length===1&&isDragging){
    const dx=e.touches[0].clientX-dragX, dy=e.touches[0].clientY-dragY;
    dragX=e.touches[0].clientX; dragY=e.touches[0].clientY;
    targetYaw+=dx*0.008; targetPitch-=dy*0.006;
    targetPitch=Math.max(-1.3,Math.min(1.3,targetPitch));
  }
  if(e.touches.length===2){
    const d=Math.hypot(
      e.touches[1].clientX-e.touches[0].clientX,
      e.touches[1].clientY-e.touches[0].clientY);
    targetDist=Math.max(0.6,Math.min(5.0,targetDist-(d-lastPinchDist)*0.012));
    lastPinchDist=d;
  }
},{passive:false});
canvas.addEventListener('touchend',e=>{
  e.preventDefault();
  const moved=Math.abs(e.changedTouches[0].clientX-tapX)+Math.abs(e.changedTouches[0].clientY-tapY);
  if(moved<12){
    // Tap = click
    const now=Date.now();
    handleClick(tapX,tapY);
    lastTapTime=now;
  }
  isDragging=false;
},{passive:false});

function handleClick(mx,my){
  const node=getNodeAt(mx,my);
  if(!node){selected=null;hideDetail();return;}
  if(selected?.item.id===node.item.id){
    if(node.item.children?.length){
      navStack.push({data:currentData});currentData=node.item.children;
      buildNodes(currentData);selected=null;
      document.getElementById('btn-back').classList.remove('hidden');
      hideDetail();return;
    }
    selected=null;hideDetail();return;
  }
  selected=node;showDetail(node.item);
}
function navigateBack(){
  if(!navStack.length)return;
  currentData=navStack.pop().data;buildNodes(currentData);selected=null;hideDetail();
  if(!navStack.length)document.getElementById('btn-back').classList.add('hidden');
}
function resetView(){targetYaw=0.3;targetPitch=0.2;targetDist=2.8;diveDelta=0;}

function showDetail(item){
  const isP=!!(item.children?.length);
  document.getElementById('d-tag').textContent=isP?'Bereich':'Tool / Skript';
  document.getElementById('d-name').textContent=item.label;
  document.getElementById('d-desc').textContent=item.desc||item.path||'';
  const conns=(item.connections||[]).map(id=>NODE_MAP[id]?.label||id);
  document.getElementById('d-list').innerHTML=
    (isP?item.children.map(c=>`<li><span class="d-pip" style="background:${c.color}"></span>${c.label}</li>`).join('')
    :`<li><span class="d-pip" style="background:${item.color}"></span>${item.path||'–'}</li>`)
    +(conns.length?`<li><span class="d-pip" style="background:#4a8ab0"></span>↔ ${conns.join(', ')}</li>`:'');
  document.getElementById('detail').classList.add('show');
}
function hideDetail(){document.getElementById('detail').classList.remove('show');}

// ─── DRAW HELPERS ──────────────────────────────────────────────────────────
function ha(hex,a){
  const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${+a.toFixed(3)})`;
}

// Label rendered INSIDE the ring
function drawLabel(px,py,R,label,col,alpha,isSel){
  const fs=Math.max(8, Math.min(13, R*0.38));
  ctx.save();
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font=`300 ${fs}px 'Inter',sans-serif`;
  // Subtle shadow for legibility
  ctx.shadowBlur=isSel?10:6;
  ctx.shadowColor=ha('#07080f',0.9);
  // Highlight stroke (1px behind, brighter)
  const r2=parseInt(col.slice(1,3),16),g2=parseInt(col.slice(3,5),16),b2=parseInt(col.slice(5,7),16);
  ctx.fillStyle=`rgba(${Math.min(255,r2+120)},${Math.min(255,g2+110)},${Math.min(255,b2+75)},${(alpha*0.55).toFixed(3)})`;
  ctx.fillText(label,px,py+0.7);
  ctx.shadowBlur=isSel?8:4;
  ctx.fillStyle=ha(col,alpha*(isSel?1.0:0.92));
  ctx.fillText(label,px,py);
  ctx.restore();
}

function drawIcon(cx,cy,icon,col,alpha,s){
  ctx.save();
  ctx.strokeStyle=ha(col,alpha); ctx.fillStyle=ha(col,alpha);
  ctx.lineWidth=1.3; ctx.lineCap='round'; ctx.lineJoin='round';
  switch(icon){
    case 'clock':
      ctx.beginPath();ctx.arc(cx,cy,s,0,Math.PI*2);ctx.stroke();
      ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx,cy-s*0.58);ctx.stroke();
      ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+s*0.42,cy+s*0.28);ctx.stroke();
      ctx.beginPath();ctx.arc(cx,cy,s*0.1,0,Math.PI*2);ctx.fill();
      break;
    case 'invoice':
      ctx.strokeRect(cx-s*0.6,cy-s*0.78,s*1.2,s*1.55);
      for(let i=0;i<3;i++){const ly=cy-s*0.32+i*s*0.42;ctx.beginPath();ctx.moveTo(cx-s*0.38,ly);ctx.lineTo(cx+s*0.38,ly);ctx.stroke();}
      break;
    case 'clipboard':
      ctx.strokeRect(cx-s*0.65,cy-s*0.6,s*1.3,s*1.45);
      ctx.beginPath();ctx.moveTo(cx-s*0.28,cy-s*0.6);ctx.lineTo(cx-s*0.28,cy-s*0.85);ctx.lineTo(cx+s*0.28,cy-s*0.85);ctx.lineTo(cx+s*0.28,cy-s*0.6);ctx.stroke();
      for(let i=0;i<3;i++){
        const ly=cy-s*0.12+i*s*0.4;
        ctx.beginPath();ctx.arc(cx-s*0.38,ly,s*0.09,0,Math.PI*2);ctx.fill();
        ctx.beginPath();ctx.moveTo(cx-s*0.18,ly);ctx.lineTo(cx+s*0.38,ly);ctx.stroke();
      }
      break;
    case 'network':
      [[0,-s*0.75],[s*0.7,s*0.38],[-s*0.7,s*0.38]].forEach(([nx,ny])=>{
        ctx.beginPath();ctx.arc(cx+nx,cy+ny,s*0.16,0,Math.PI*2);ctx.fill();
        ctx.globalAlpha=alpha*0.45;ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+nx,cy+ny);ctx.stroke();ctx.globalAlpha=1;
      });
      ctx.beginPath();ctx.arc(cx,cy,s*0.2,0,Math.PI*2);ctx.fill();
      break;
    case 'terminal':
      ctx.strokeRect(cx-s,cy-s*0.72,s*2,s*1.44);
      ctx.font=`${Math.round(s*0.88)}px 'DM Mono',monospace`;
      ctx.textAlign='left';ctx.textBaseline='middle';
      ctx.fillText('>_',cx-s*0.6,cy+s*0.06);
      break;
    case 'file':
      ctx.beginPath();
      ctx.moveTo(cx-s*0.48,cy-s*0.72);ctx.lineTo(cx+s*0.18,cy-s*0.72);
      ctx.lineTo(cx+s*0.48,cy-s*0.42);ctx.lineTo(cx+s*0.48,cy+s*0.72);
      ctx.lineTo(cx-s*0.48,cy+s*0.72);ctx.closePath();ctx.stroke();
      ctx.beginPath();ctx.moveTo(cx+s*0.18,cy-s*0.72);ctx.lineTo(cx+s*0.18,cy-s*0.42);ctx.lineTo(cx+s*0.48,cy-s*0.42);ctx.stroke();
      break;
  }
  ctx.restore();
}

function drawBezier(x1,y1,x2,y2,col,alpha,lw=0.9){
  const mx=(x1+x2)/2, my=(y1+y2)/2;
  const dx=x2-x1,dy=y2-y1,dist=Math.sqrt(dx*dx+dy*dy);
  if(dist<2)return;
  const mag=dist*0.26;
  const c1x=mx-dy/dist*mag, c1y=my+dx/dist*mag;
  const c2x=mx+dy/dist*mag, c2y=my-dx/dist*mag;

  if(bgMode==='white' && alpha>0.4){
    // Active B&W line: gradient along curve dark→mid→dark
    const steps=40;
    for(let i=0;i<steps;i++){
      const t0=i/steps, t1=(i+1)/steps;
      const tm=(t0+t1)/2;
      // Sine brightness: endpoints dark, midpoint slightly lighter
      const bright=Math.round(12+60*Math.sin(tm*Math.PI));
      const bx0=Math.pow(1-t0,3)*x1+3*Math.pow(1-t0,2)*t0*c1x+3*(1-t0)*t0*t0*c2x+t0*t0*t0*x2;
      const by0=Math.pow(1-t0,3)*y1+3*Math.pow(1-t0,2)*t0*c1y+3*(1-t0)*t0*t0*c2y+t0*t0*t0*y2;
      const bx1=Math.pow(1-t1,3)*x1+3*Math.pow(1-t1,2)*t1*c1x+3*(1-t1)*t1*t1*c2x+t1*t1*t1*x2;
      const by1=Math.pow(1-t1,3)*y1+3*Math.pow(1-t1,2)*t1*c1y+3*(1-t1)*t1*t1*c2y+t1*t1*t1*y2;
      ctx.beginPath();ctx.moveTo(bx0,by0);ctx.lineTo(bx1,by1);
      ctx.strokeStyle=`rgba(${bright},${bright},${bright-2},${alpha.toFixed(2)})`;
      ctx.lineWidth=lw;ctx.stroke();
    }
    // Midpoint dot
    const gx2=Math.pow(0.5,3)*x1+3*Math.pow(0.5,2)*0.5*c1x+3*0.5*0.25*c2x+0.125*x2;
    const gy2=Math.pow(0.5,3)*y1+3*Math.pow(0.5,2)*0.5*c1y+3*0.5*0.25*c2y+0.125*y2;
    ctx.beginPath();ctx.arc(gx2,gy2,2.5,0,Math.PI*2);
    ctx.fillStyle=`rgba(15,13,10,${alpha.toFixed(2)})`;ctx.fill();
  } else {
    ctx.beginPath();ctx.moveTo(x1,y1);
    ctx.bezierCurveTo(c1x,c1y,c2x,c2y,x2,y2);
    ctx.strokeStyle=ha(col,alpha);ctx.lineWidth=lw;ctx.stroke();
    if(alpha>0.3){
      const gx2=Math.pow(0.5,3)*x1+3*Math.pow(0.5,2)*0.5*c1x+3*0.5*0.25*c2x+0.125*x2;
      const gy2=Math.pow(0.5,3)*y1+3*Math.pow(0.5,2)*0.5*c1y+3*0.5*0.25*c2y+0.125*y2;
      ctx.beginPath();ctx.arc(gx2,gy2,2,0,Math.PI*2);
      ctx.fillStyle=ha(col,alpha*0.75);ctx.fill();
    }
  }
}

function drawNode(px,py,depth,item,isParent,isSel,isHov,isConn,hasSel){
  let a=0.82;
  if(hasSel){a=isSel?1.0:isConn?0.90:0.28;}
  if(isHov&&!hasSel)a=1.0;
  const fa=a*Math.max(0.2,Math.min(1.0,depth));
  const col = item.color;
  const R=(isParent?(isSel?44:38):(isSel?30:24))*depth;
  const bw = bgMode==='white';

  // ── B&W MODE ──────────────────────────────────────────────────────────────
  if(bw){
    const pulse = isSel ? 0.5+0.18*Math.sin(glowT*2.2) : 0;

    // Node interior fill: gradient white→grey (normal) or black→dark (selected)
    const fillGrad = ctx.createRadialGradient(px-R*0.25,py-R*0.25,0, px,py,R*1.1);
    if(isSel){
      fillGrad.addColorStop(0,'#2a2825');
      fillGrad.addColorStop(1,'#0f0e0c');
    } else {
      fillGrad.addColorStop(0,'#f8f5ef');
      fillGrad.addColorStop(0.7,'#e8e2d6');
      fillGrad.addColorStop(1,'#ccc6b8');
    }
    ctx.beginPath(); ctx.arc(px,py,R-1,0,Math.PI*2);
    ctx.fillStyle=fillGrad; ctx.fill();

    // Hover: extra dark ring outside
    if(isHov&&!isSel){
      ctx.beginPath();ctx.arc(px,py,R*1.45,0,Math.PI*2);
      ctx.strokeStyle='rgba(30,28,24,0.25)';ctx.lineWidth=1.5;ctx.stroke();
    }

    // Selected: outer pulse ring
    if(isSel){
      ctx.beginPath();ctx.arc(px,py,R*1.5+pulse*6,0,Math.PI*2);
      ctx.strokeStyle=`rgba(20,18,14,${(0.35+pulse*0.25).toFixed(2)})`;
      ctx.lineWidth=1.2;ctx.stroke();
    }

    // Outer ring: gradient dark bottom-right → light top-left
    const segs=180;
    for(let k=0;k<segs;k++){
      const ang=(Math.PI*2/segs)*k;
      const diff=Math.abs(((k/segs*360+135)%360)-180)/180; // bright at top-left
      // Normal: dark ring; Selected: inverted (bright ring)
      let rv,gv,bv;
      if(isSel){
        rv=gv=Math.round(200+diff*55); bv=Math.round(190+diff*55);
      } else {
        rv=gv=Math.round(18+diff*110);  bv=Math.round(14+diff*105);
      }
      const x1=px+R*Math.cos(ang),y1=py+R*Math.sin(ang);
      const x2=px+R*Math.cos(ang+Math.PI*2/segs),y2=py+R*Math.sin(ang+Math.PI*2/segs);
      ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=`rgba(${rv},${gv},${bv},${fa.toFixed(2)})`;
      ctx.lineWidth=isSel?2.8:2.0; ctx.stroke();
    }

    // Inner ring
    if(isParent){
      const R2=R*0.62;
      for(let k=0;k<100;k++){
        const ang=(Math.PI*2/100)*k;
        const diff=Math.abs(((k/100*360+135)%360)-180)/180;
        const v=isSel?Math.round(120+diff*100):Math.round(80+diff*100);
        const x1=px+R2*Math.cos(ang),y1=py+R2*Math.sin(ang);
        const x2=px+R2*Math.cos(ang+Math.PI*2/100),y2=py+R2*Math.sin(ang+Math.PI*2/100);
        ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
        ctx.strokeStyle=`rgba(${v},${v},${v},${(fa*0.7).toFixed(2)})`;
        ctx.lineWidth=0.9;ctx.stroke();
      }
    }

    // Icon + label color: dark on light, light on dark
    const iconCol = isSel ? '#d8d2c8' : '#1a1816';
    const labelCol = isSel ? '#e8e2d8' : '#0f0e0c';
    const iconY=isParent?py-R*0.22:py-R*0.18;
    drawIcon(px,iconY,item.icon||'file',iconCol,fa*(isSel?0.92:0.82),R*(isParent?0.32:0.36));

    // Label
    const labelY=py+R*(isParent?0.35:0.38);
    const fs=Math.max(8,Math.min(13,R*0.38));
    ctx.save();
    ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.font=`300 ${fs}px 'Inter',sans-serif`;
    ctx.shadowBlur=isSel?0:3; ctx.shadowColor='rgba(255,252,248,0.8)';
    ctx.fillStyle=isSel?'rgba(235,228,215,0.95)':'rgba(12,10,8,0.92)';
    ctx.fillText(item.label,px,labelY);
    ctx.restore();

    // Path
    if(!isParent&&item.path){
      const pfs=Math.max(7,8*depth);
      ctx.save();ctx.textAlign='center';ctx.textBaseline='top';
      ctx.font=`300 ${pfs}px 'DM Mono',monospace`;
      ctx.fillStyle=`rgba(100,95,88,${(fa*0.65).toFixed(2)})`;
      ctx.fillText(item.path,px,py+R+4*depth);
      ctx.restore();
    }
    return;
  }

  // ── COLOR MODES (space / circuit) ────────────────────────────────────────
  if(isSel||isHov){
    const pulse=isSel?0.65+0.28*Math.sin(glowT*2.2):0.42;
    const haloBg = bgMode==='circuit'?'#0e0f0f':'#07080f';
    const haloCol = bgMode==='circuit'?'#ddddda':col;
    const gr=ctx.createRadialGradient(px,py,0,px,py,R*3.0);
    gr.addColorStop(0,ha(haloCol,pulse*0.45));gr.addColorStop(0.4,ha(haloCol,pulse*0.18));gr.addColorStop(1,ha(haloBg,0));
    ctx.beginPath();ctx.arc(px,py,R*3.0,0,Math.PI*2);ctx.fillStyle=gr;ctx.fill();
  }
  const segs=180;
  for(let k=0;k<segs;k++){
    const ang=(Math.PI*2/segs)*k;
    const diff=Math.abs(((k/segs*360+45)%360)-180)/180;
    const x1=px+R*Math.cos(ang),y1=py+R*Math.sin(ang);
    const x2=px+R*Math.cos(ang+Math.PI*2/segs),y2=py+R*Math.sin(ang+Math.PI*2/segs);
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
    ctx.strokeStyle=ha(col,fa*(0.15+0.85*diff));
    ctx.lineWidth=isSel?2.8:1.8;ctx.stroke();
  }
  if(isParent){
    const R2=R*0.62;
    for(let k=0;k<100;k++){
      const ang=(Math.PI*2/100)*k;
      const diff=Math.abs(((k/100*360+45)%360)-180)/180;
      const x1=px+R2*Math.cos(ang),y1=py+R2*Math.sin(ang);
      const x2=px+R2*Math.cos(ang+Math.PI*2/100),y2=py+R2*Math.sin(ang+Math.PI*2/100);
      ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
      ctx.strokeStyle=ha(col,fa*(0.12+0.42*diff));
      ctx.lineWidth=0.9;ctx.stroke();
    }
  }
  ctx.beginPath();ctx.arc(px+R,py,isSel?3.5:2,0,Math.PI*2);
  ctx.fillStyle=ha(col,fa*0.9);ctx.fill();
  const iconY=isParent?py-R*0.22:py-R*0.18;
  drawIcon(px,iconY,item.icon||'file',col,fa*(isSel?1.0:0.78),R*(isParent?0.32:0.36));
  const labelY=py+R*(isParent?0.35:0.38);
  drawLabel(px,labelY,R,item.label,col,fa,isSel);
  if(!isParent&&item.path){
    const pfs=Math.max(7,8*depth);
    ctx.save();ctx.textAlign='center';ctx.textBaseline='top';
    ctx.font=`300 ${pfs}px 'DM Mono',monospace`;
    ctx.fillStyle=ha('#706050',fa*0.55);
    ctx.fillText(item.path,px,py+R+4*depth);
    ctx.restore();
  }
}

// ─── MAIN LOOP ─────────────────────────────────────────────────────────────
function frame(){
  requestAnimationFrame(frame);
  glowT+=0.016;

  // Smooth orbit lerp
  const t=0.09;
  orbitYaw   += (targetYaw-orbitYaw)*t;
  orbitPitch += (targetPitch-orbitPitch)*t;
  // Smooth zoom
  orbitDist  += (targetDist-orbitDist)*0.08;
  // Dive: apply accumulated delta, decay
  if(Math.abs(diveDelta)>0.001){
    orbitDist=Math.max(0.6,Math.min(5.0,orbitDist+diveDelta*0.12));
    diveDelta*=0.85;
  }

  // Clear
  const isWhite = bgMode==='white';
  if(isWhite){
    // Radial gradient: warm-white center → dark warm-grey edges
    const bgGrad = ctx.createRadialGradient(W/2,H/2,0, W/2,H/2,Math.max(W,H)*0.72);
    bgGrad.addColorStop(0,   '#f8f4ec');
    bgGrad.addColorStop(0.35,'#e4ddd0');
    bgGrad.addColorStop(0.62,'#bfb5a5');
    bgGrad.addColorStop(0.82,'#8c8070');
    bgGrad.addColorStop(1.0, '#3e3830');
    ctx.fillStyle=bgGrad; ctx.fillRect(0,0,W,H);
  } else if(bgMode==='circuit'){
    ctx.fillStyle='#0e0f0f'; ctx.fillRect(0,0,W,H);
    const vig=ctx.createRadialGradient(W/2,H/2,H*0.25,W/2,H/2,H*0.9);
    vig.addColorStop(0,'rgba(0,0,0,0)');vig.addColorStop(1,'rgba(0,0,0,0.75)');
    ctx.fillStyle=vig; ctx.fillRect(0,0,W,H);
  } else {
    ctx.fillStyle='#07080f'; ctx.fillRect(0,0,W,H);
    const vig=ctx.createRadialGradient(W/2,H/2,H*0.25,W/2,H/2,H*0.9);
    vig.addColorStop(0,'rgba(0,0,0,0)');vig.addColorStop(1,'rgba(0,0,0,0.65)');
    ctx.fillStyle=vig; ctx.fillRect(0,0,W,H);
  }

  if(bgMode==='space'){
    stars.forEach(s=>{
      const sp=projectStar(s.yaw,s.pitch);
      if(!sp||sp.sx<-20||sp.sx>W+20||sp.sy<-20||sp.sy>H+20)return;
      const tw=0.62+0.38*Math.sin(glowT*s.spd+s.tw);
      const baseA=s.s>1.8?0.82:s.s>1.2?0.55:0.30;
      const a=baseA*tw;
      const r=s.s*0.62;
      const sr=s.warm?240:218,sg=s.warm?220:215,sb=s.warm?188:238;
      if(s.s>1.5){
        ctx.beginPath();ctx.arc(sp.sx,sp.sy,r*4,0,Math.PI*2);
        ctx.fillStyle=`rgba(${sr},${sg},${sb},${(a*0.12).toFixed(3)})`;ctx.fill();
        ctx.beginPath();ctx.arc(sp.sx,sp.sy,r*2,0,Math.PI*2);
        ctx.fillStyle=`rgba(${sr},${sg},${sb},${(a*0.32).toFixed(3)})`;ctx.fill();
      }
      ctx.beginPath();ctx.arc(sp.sx,sp.sy,Math.max(0.5,r),0,Math.PI*2);
      ctx.fillStyle=`rgba(${sr},${sg},${sb},${a.toFixed(3)})`;ctx.fill();
    });
  } else if(bgMode==='circuit'){
    // Circuit dot field
    // 3D dust cloud – project each grain with orbit camera
    dustCloud.forEach(g=>{
      const p=project(g.x, g.y, g.z);
      if(p.d<=0||p.sx<-40||p.sx>W+40||p.sy<-40||p.sy>H+40)return;
      // Depth-based: closer = bigger & brighter, far = tiny & dim
      const depthScale=Math.min(1.8, p.d*1.2);
      const r2=g.size*depthScale*0.6;
      if(r2<0.1)return;
      const tw=0.6+0.4*Math.sin(glowT*g.spd+g.phase);
      const a=g.alpha*tw*Math.min(1, depthScale*0.7);
      ctx.fillStyle=`rgba(${g.bright},${g.bright},${g.bright},${a.toFixed(3)})`;
      ctx.fillRect(p.sx-r2, p.sy-r2, r2*2, r2*2);
    });
    // No grid – pure dust
  } else {
    // Beige: simple ellipses, rotating with camera, no fill, no bugs
    const cx2=W/2, cy2=H/2;
    const bR=Math.min(W,H)*0.34;
    // Each ellipse: rx fixed, ry compressed by pitch angle → suggests sphere
    [
      {rot:0,             pitchMod:0,            rx:1.0, alpha:0.20, lw:1.2},
      {rot:Math.PI/2,     pitchMod:0,            rx:0.96,alpha:0.15, lw:1.0},
      {rot:Math.PI/4,     pitchMod:Math.PI/6,    rx:0.92,alpha:0.11, lw:0.8},
      {rot:-Math.PI/4,    pitchMod:-Math.PI/7,   rx:0.88,alpha:0.09, lw:0.7},
      {rot:Math.PI*0.7,   pitchMod:Math.PI/5,    rx:0.82,alpha:0.08, lw:0.7},
    ].forEach(e=>{
      const angle = orbitYaw * 0.4 + e.rot;
      const pitch = orbitPitch * 0.5 + e.pitchMod;
      const rx = bR * e.rx;
      const ry = Math.max(5, rx * Math.abs(Math.cos(pitch)));
      const cpitch = Math.abs(Math.cos(pitch));
      const off = 10;
      // Outer thin flank
      ctx.beginPath();
      ctx.ellipse(cx2, cy2, rx+off, Math.max(4, ry+off*cpitch), angle, 0, Math.PI*2);
      ctx.strokeStyle=`rgba(45,38,28,${(e.alpha*0.42).toFixed(3)})`;
      ctx.lineWidth=0.55; ctx.stroke();
      // Center main line
      ctx.beginPath();
      ctx.ellipse(cx2, cy2, rx, ry, angle, 0, Math.PI*2);
      ctx.strokeStyle=`rgba(45,38,28,${e.alpha})`;
      ctx.lineWidth=e.lw; ctx.stroke();
      // Inner thin flank
      ctx.beginPath();
      ctx.ellipse(cx2, cy2, Math.max(5, rx-off), Math.max(4, ry-off*cpitch), angle, 0, Math.PI*2);
      ctx.strokeStyle=`rgba(45,38,28,${(e.alpha*0.42).toFixed(3)})`;
      ctx.lineWidth=0.55; ctx.stroke();
    });
  }

  // Nodes
  const projected=nodes.map(n=>{
    const ox=n.fa*Math.sin(glowT*n.fs+n.fp);
    const oy=n.fa*Math.cos(glowT*n.fs*0.7+n.fp+1);
    return {n, p:project(n.x3+ox,n.y3+oy,n.z3+ox*0.5)};
  });
  projected.sort((a,b)=>a.p.vz-b.p.vz);

  const connIds=selected?new Set(selected.item.connections||[]):new Set();
  const selId=selected?.item.id;

  // Connections
  const drawn=new Set();
  projected.forEach(({n,p})=>{
    (n.item.connections||[]).forEach(cid=>{
      const key=[n.item.id,cid].sort().join('--');
      if(drawn.has(key))return;drawn.add(key);
      const tgt=projected.find(x=>x.n.item.id===cid);
      if(!tgt||p.d<=0||tgt.p.d<=0)return;
      const active=selId&&(n.item.id===selId||cid===selId);
      const alpha = bgMode==='white'
        ? (active?0.92:0.22)
        : (active?0.70+0.22*Math.sin(glowT*1.8):0.07);
      const lineCol = bgMode==='white'
        ? (active?'#0f0e0c':'#5a5248')
        : bgMode==='circuit'
          ? (active?'#e8d880':'#505050')
          : (active?n.item.color:'#706050');
      const lw = bgMode==='white' ? (active?2.2:1.0) : (active?1.8:0.9);
      drawBezier(p.sx,p.sy,tgt.p.sx,tgt.p.sy,lineCol,alpha,lw);
    });
  });

  // Nodes
  projected.forEach(({n,p})=>{
    if(p.d<=0)return;
    const item=n.item, isSel=selId===item.id, isConn=connIds.has(item.id);
    const isHov=hovered?.item.id===item.id, hasSel=!!selId;
    if(isConn&&selected){
      const sp=projected.find(x=>x.n.item.id===selId);
      if(sp){p.sx+=(sp.p.sx-p.sx)*0.06;p.sy+=(sp.p.sy-p.sy)*0.06;}
    }
    drawNode(p.sx,p.sy,p.d,item,n.isParent,isSel,isHov,isConn,hasSel);
  });
}

window.addEventListener('resize',()=>{W=window.innerWidth;H=window.innerHeight;canvas.width=W;canvas.height=H;});
frame();
</script>
</body>
</html>
